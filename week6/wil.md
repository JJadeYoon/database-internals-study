# **B-Tree 구현 (페이지 헤더, 검색, 전파)**


## 1. Page Header와 Magic Numbers


### 1.1 Page Header의 역할

페이지 헤더는 해당 페이지에 대한 메타데이터를 저장하는 공간이다. 네비게이션, 유지보수, 최적화에 사용되는 정보들이 포함된다.

- 페이지 내용과 레이아웃을 설명하는 **플래그**
- 페이지 내 **셀의 개수**
- 빈 공간을 표시하는 상한/하한 **오프셋** (셀 오프셋과 데이터 추가용)
- **메타데이터**

**페이지, 셀, 블럭의 계층적 관계**

```
🔸 셀 (Cell) - 실제 데이터 저장 단위
    ↓ 여러 셀이 모여서
🔸 페이지 (Page) - 논리적 관리 단위  
    ↓ 페이지가 물리적으로 저장되는 곳
🔸 블럭 (Block) - 물리적 디스크 단위
```

- 블럭 - 물리적 기반
    - 디스크의 최소 I/O 단위
    - 데이터베이스가 직접 제어할 수 없는 물리적 제약
- 페이지 - 논리적 관리 단위
    - 데이터베이스가 관리하는 논리적 단위
    - 일반적으로 블럭 크기의 배수 (4KB, 8KB, 16KB 등)
    - B-Tree의 노드 하나가 보통 한 페이지에 대응
    - 페이지 헤더 + 실제 데이터 영역으로 구성
- 셀 - 데이터 저장 단위
    - 실제 키-값 쌍이나 인덱스 엔트리를 저장하는 단위
    - 가변 크기 (키와 값의 크기에 따라 달라짐)
    - 페이지 내에서 삽입 순서대로 물리적 저장
    - 셀 포인터를 통한 간접 참조로 논리적 순서 유지
</aside>

### 1.2 실제 DBMS 구현 사례

- **PostgreSQL**: 페이지 크기와 레이아웃 버전을 헤더에 저장
- **MySQL InnoDB**: 힙 레코드 수, 레벨, 기타 구현별 값들을 저장
- **SQLite**: 셀의 개수와 rightmost 포인터를 저장

### 1.3 Magic Numbers

파일이나 페이지 헤더에 배치되는 값으로, 페이지의 종류와 버전 같은 정보를 나타낸다.

- 검증과 무결성 체크에 사용
    - 쓰기 시 특정 바이트 시퀀스를 헤더에 배치 (예: 50 41 47 45 - "PAGE"의 hex)
    - 읽기 시 헤더의 4바이트를 예상 바이트 시퀀스와 비교하여 검증
    - 랜덤 오프셋에서 정확히 매칭될 확률이 매우 낮아 오프셋이 올바른지 확인 가능

**매직 넘버가 필요한 이유**

> *데이터베이스는 읽어온 데이터가 정말 B-Tree 페이지인지 어떻게 확신할 수 있을까?*
> 

상황: 데이터베이스가 페이지 #100을 읽으려고 함

정상적인 경우: 파일 오프셋 400KB → [B-Tree 페이지 데이터]

문제가 발생한 경우: 파일 오프셋 400KB → [이미지 파일 데이터] (다른 파일이 섞임)

> *특별한 서명(signature)을 페이지 시작 부분에 넣어 확인하자*
> 

```
IF (페이지 첫 4바이트 == 예상 매직 넘버):
    → 올바른 페이지일 가능성이 매우 높음
ELSE:
    → 확실히 잘못된 데이터 → 오류 발생
```

</aside>

## 2. Sibling Links


### 2.1 개념

일부 구현에서는 좌우 형제 페이지를 가리키는 순방향/역방향 링크를 저장하여, 부모로 돌아가지 않고도 인접 노드를 찾을 수 있게 한다.

### 2.2 장단점

**2.2.1 장점**

- 부모 노드를 거치지 않고 직접 형제 노드 접근 가능
- 같은 레벨에서의 순차 스캔이 효율적

**2.2.2 단점**

- 분할과 병합 연산시 복잡성 증가 - 형제 오프셋도 함께 업데이트 필요
    
    ex. 최우측이 아닌 노드가 분할될 때, 우측 형제의 역방향 포인터를 새로 생성된 노드로 재설정 필요
    

### 2.3 동시성 고려사항

Sibling links를 사용하는 경우 형제 노드의 업데이트로 이핸 추가적인 락킹이 필요할 수 있다. 분할/병합되는 노드 외에도 다른 노드들도 함께 고려해야 하기 때문이다.

```
분할 전:
[A] ←→ [B: 키1,키2,키3,키4,키5] ←→ [C]

분할 후:
[A] ←→ [B: 키1,키2] ←→ [B': 키3,키4,키5] ←→ [C]

1. 노드 B:
   - right_sibling = C의 주소 -> B'의 주소로 변경

2. 노드 B' (새로 생성):  
   - left_sibling = B'의 주소
   - right_sibling = C의 주소

3. 노드 C (형제 노드):
   - left_sibling = B의 주소 → B'의 주소로 변경
```

Sibling links를 사용함으로, 관련 없는 C도 함께 조작해야 하고, 락킹이 추가적으로 필요하다.

```
1. 노드 B (쓰기 락) - 내용 수정
2. 노드 C (쓰기 락) - left_sibling 포인터 변경  
3. 부모 노드 (쓰기 락) - 새로운 키 추가
```

이때 동시에 여러 분할이 일어나는 경우 데드락이 발생할 수도 있다.

```
Transaction_1: A ←→ B 분할
Transaction_2: B ←→ C 분할

두 트랜잭션 모두 노드 B에 대한 락이 필요!
→ 순서 문제와 데드락 가능성 여전히 존재
```

## 3. Rightmost Pointers 처리


### 3.1 B-Tree의 포인터 불변 조건

B-Tree 구분 키는 엄격한 불변 조건을 가진다.

- 트리를 서브트리로 분할하고 탐색하는 데 사용
- 항상 키보다 포인터가 하나 더 많음 (Rightmost Pointer)

### 3.2 두 가지 구현 방식

**3.2.1 분리된 저장**

- 각 분리 키마다 자식 포인터 보유
- 마지막 포인터는 별도 저장 (어떤 키와도 쌍을 이루지 않음)
- SQLite에서 이 방식을 사용하여 헤더에 구현

**3.2.2 High Key 사용**

- 각 노드에 추가 키(K_N+1) 추가
- 포인터 P_N이 가리키는 서브트리에 저장 가능한 키의 상한 지정
    - 검색 공간의 차이
        
        **기본 방식**: +∞까지 확장
        **High Key 방식**: K3의 상한까지로 제한
        
- PostgreSQL에서 Blink-Trees용으로 사용

포인터를 쌍으로 저장할 수 있어 각 셀이 대응되는 포인터를 가지게 되므로, rightmost 포인터 처리시 엣지 케이스를 고려할 필요가 줄어든다.

## 4. Overflow Pages


### 4.1 Overflow Pages

고정 크기 페이지에서 가변 크기 값을 처리하기 위한 메커니즘이다.

**4.1.1 문제 상황**

- 노드 크기와 트리 팬아웃은 고정값
- 가변 크기 값이 존재할 때 범용적 최적값 설정이 어려움
- 값이 클 경우 페이지에 몇 개만 들어가고, 작을 경우 공간 낭비 발생

**4.1.2 해결 방안**

- 기본 페이지 크기 4K에서 시작
- 데이터 크기가 4K를 초과하면 4K 단위로 확장 페이지 할당
- 원본 페이지에서 확장 페이지로 링크 연결
- 이러한 연결된 페이지 확장을 **overflow pages**라 명명

**4.1.3 실제 구현**

- 대부분의 B-Tree 구현은 고정된 payload 바이트만 B-Tree 노드에 직접 저장
- 나머지는 overflow 페이지로 분할 (max_payload_size로 계산)
- 항상 최소한의 여유 공간 보장

## 5. Binary Search 구현


### 5.1 기본 이진 탐색

노드 내 키 위치를 찾기 위해 이진 탐색을 사용한다. 정렬된 데이터에서만 작동하므로 키 순서 유지가 필수적이다.

- 정렬된 배열과 탐색 키를 입력받아 숫자 반환
- 양수 반환: 키 발견, 배열에서의 위치 명시
- 음수 반환: 키 미존재, **삽입 지점** 제공
    
    음수의 절댓값은 탐색 키를 순서 보존하며 삽입할 수 있는 주어진 키보다 큰 첫 번째 요소의 인덱스를 나타냄
    

### 5.2 B-Tree에서의 특수성

데이터는 리프에만 존재하기 때문에 상위 레벨 탐색에서는 정확한 매치보다는 **탐색 방향**이 중요하다.

- 탐색 키보다 큰 첫 번째 값을 찾아야 함
- 해당하는 자식 링크를 따라 연관된 서브트리로 이동

### 5.3 Indirection Pointers(간접 포인터)를 사용한 이진 탐색

B-Tree 페이지의 셀은 삽입 순서로 저장되며, 셀 오프셋만이 논리적 요소 순서를 유지한다.

1. 중간 셀 오프셋 선택
2. 포인터를 따라 셀 위치 확인
3. 셀의 키와 탐색 키 비교
4. 탐색을 왼쪽/오른쪽으로 계속할지 결정
5. 탐색 요소나 삽입 지점을 찾을 때까지 재귀적 반복

## 6. Propagating Splits and Merges


### 6.1 상위 레벨로의 전파

분할과 병합은 상위 레벨로 전파될 수 있고, 이를 위해 분할하는 리프나 병합하는 리프 쌍에서 루트 노드까지의 경로를 거슬러 올라갈 수 있어야 한다.

### 6.2 Parent Pointers vs Breadcrumbs

**6.2.1 Parent Pointers**

- B-Tree 노드에 부모 노드 포인터 포함
- 하위 레벨 페이지는 상위 레벨에서 참조될 때 항상 페이징됨
- 디스크에 정보를 유지할 필요 없음
- 부모 변경시마다 업데이트 필요 (분할, 병합, 리밸런싱 시)

**6.2.2 Breadcrumbs**

- 루트에서 대상 리프 노드까지의 경로상 노드들을 추적
- 분할이나 병합 전파시 역순으로 이를 백트래킹하여 사용
- 메모리의 스택에 경로를 저장
- PostgreSQL에서 BTStack으로 내부 참조
