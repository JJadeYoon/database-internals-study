# Week 9 Recovery & Concurrency Control

# 1. Recovery

## 1.1 Write-Ahead Log (WAL)

데이터베이스 시스템은 여러 하드웨어 및 소프트웨어 계층 위에 구축되며, 각 계층은 자체적인 안정성과 신뢰성 문제를 가질 수 있다. WAL은 충돌 및 트랜잭션 복구에 사용되는 추가 전용 보조 디스크 상주 구조이다.

### 1.1.1 WAL의 주요 기능

- 데이터베이스 시스템의 내구성 의미론을 보장하면서 페이지 캐시가 디스크 상주 페이지에 대한 업데이트를 버퍼링할 수 있게 함
- 영향받은 페이지의 캐시된 복사본이 디스크에서 동기화될 때까지 모든 작업을 디스크에 지속
- 데이터베이스 상태를 수정하는 모든 작업은 관련 페이지의 내용이 수정되기 전에 디스크에 로깅되어야 함 (Write-Ahead 원칙)
- 충돌의 경우 작업 로그에서 손실된 메모리 내 변경 사항을 재구성할 수 있게 함

### **❓Q1) WAL의 저장 위치와 성능**

WAL은 기본적으로 디스크에 저장된다. 하지만 성능을 위해 2단계 저장 과정을 사용한다.

- **메모리 버퍼**: 로그 레코드들이 먼저 메모리의 "로그 버퍼"에 캐시
- **디스크 플러시**: 버퍼가 채워지거나 강제(force) 작업이 발생하면 디스크에 플러시

**그러나 메모리 버퍼에 저장되면 전원이 꺼질 때 사라지기 때문에 필수적인 조건이 있다.**

- 실제 데이터 변경 **전에** 로그가 먼저 디스크에 기록되어야 함
- 트랜잭션 커밋 **전에** 반드시 디스크로 플러시
- 메모리 버퍼는 성능 최적화를 위한 임시 저장소일 뿐

**그렇다면 디스크에 플러시하는 것도 성능 문제가 있지 않을까? 
맞지만 실제 데이터를 플러시하는 것과는 다르기 때문에 전체적인 성능을 향상시킬 수 있다.**

- **순차 쓰기**: WAL은 append-only로 파일 끝에 순차적으로 쓰기 (매우 빠름)
- **배치 처리**: 여러 로그 레코드를 모아서 한 번에 디스크에 쓰기
- **실제 데이터 쓰기 지연**: WAL에만 기록하고 트랜잭션 즉시 커밋 가능
- **작은 크기**: 로그 레코드는 전체 페이지보다 훨씬 작음

## 1.2 Log Semantics

WAL은 추가 전용이며 기록된 내용은 불변이므로, 로그에 대한 모든 쓰기는 순차적이다. WAL은 로그 레코드로 구성되며, 각 레코드는 고유하고 단조 증가하는 로그 시퀀스 번호(LSN)를 가진다.

### 1.2.1 체크포인트

- 로그가 특정 표시까지의 로그 레코드가 완전히 지속되었고 더 이상 필요하지 않다는 것을 알 수 있는 방법
- **동기 체크포인트**: 모든 더티 페이지를 디스크에 플러시하도록 강제하는 프로세스
- **퍼지 체크포인트**: 작업을 계속하면서 백그라운드로 천천히 플러시

### **❓Q2) 퍼지 체크포인트와 동기 체크포인트의 차이점**

**동기 체크포인트**: "모든 일 멈춰! 지금 당장 대청소한다!"

- 모든 활동 멈춤 → 모든 방을 한꺼번에 청소 → 완전히 깨끗해질 때까지 기다림
- 문제: 청소하는 동안 아무것도 못함

**퍼지 체크포인트**: "일상생활 하면서 틈틈이 청소하자!"

- 청소 계획 세우기 → 일하면서도 백그라운드로 천천히 청소 → 모든 방 청소 완료되면 "청소 끝!" 선언
- 장점: 일상생활 방해받지 않음

```
시간축: ──────────────────────────────────────→
트랜잭션들: ████████████████████████████████ (계속 실행)
체크포인트:    [시작]        [백그라운드 플러시]     [완료]
              begin_checkpoint                   end_checkpoint
```

## 1.3 Operation Versus Data Log

상태 변경은 이전 이미지와 이후 이미지로 또는 해당하는 리두와 언두 작업으로 표현될 수 있다.

- **물리적 로그**: 완전한 페이지 상태나 바이트 단위 변경 사항을 저장
- **논리적 로그**: 현재 상태에 대해 수행되어야 하는 작업을 저장

### 1.3.1 Shadow Paging

일부 데이터베이스 시스템은 섀도우 페이징을 사용한다: 데이터 내구성과 트랜잭션 원자성을 보장하는 복사-후-쓰기 기법이다.

### **❓Q3) 섀도우 페이징의 작동 방식**

**일반적인 방식** (기존 페이지 수정):

- 살고 있는 집을 그대로 뜯어고치기
- 문제: 중간에 실패하면 집이 망가진 상태로 남음

**섀도우 페이징 방식**:

- 옆에 똑같은 집을 새로 짓고 거기서 리모델링
- 완성되면 주소만 바꿔서 새 집으로 이사
- 문제 생기면 원래 집으로 돌아가기

```
1단계: 페이지 포인터 → [페이지 A: 김철수, 나이=25] (원본)
                           ↓ 복사
                   [페이지 A': 김철수, 나이=26] (섀도우)

2단계: 페이지 포인터 → [페이지 A': 김철수, 나이=26] (새 버전)
							   
							     [페이지 A: 김철수, 나이=25] (이전 버전, 나중에 삭제)
```

## 1.4 Steal and Force Policies

데이터베이스 관리 시스템들은 메모리에서 이루어진 변경 사항이 언제 디스크에 플러시되어야 하는지를 결정하기 위해 스틸/노-스틸 및 포스/노-포스 정책을 정의한다.

### **❓Q4) Steal vs Force 정책**

**스틸과 포스가 어떻게 다를까?
트랜잭션을 기준으로 하는 시간축으로 구분한다.**

```
트랜잭션 시작 ──────── 트랜잭션 진행 중 ──────── 커밋 시점
                         ↑                    ↑
                    Steal 정책              Force 정책
                    (언제 쓸까?)            (다 써야 할까?)
```

**Steal 정책**: "커밋 전에 써도 될까?"

- **Steal**: 커밋 전인데 디스크에 써버림
- **No-Steal**: 커밋 전까지는 메모리에만 보관

**Force 정책**: "커밋할 때 다 써야 할까?"

- **Force**: 모든 변경사항을 지금 당장 디스크에 다 써야 함
- **No-Force**: 일부는 나중에 써도 됨

**4가지 조합**:

| 정책 조합 | 특징 | 복구 방법 |
| --- | --- | --- |
| Steal + Force | 커밋 전에 쓰고, 커밋 시 다 씀 | Undo + Redo 둘 다 필요 |
| Steal + No-Force | 커밋 전에 쓰지만, 커밋 시 안 써도 됨 | Undo + Redo 둘 다 필요 |
| No-Steal + Force | 커밋 전엔 안 쓰고, 커밋 시 다 씀 | 복구 거의 불필요 |
| No-Steal + No-Force | 커밋 전엔 안 쓰고, 커밋 시도 안 써도 됨 | Redo만 필요 |

## 1.5 ARIES

ARIES는 스틸/노-포스 복구 알고리즘이다. 복구 중에 성능을 개선하기 위해 물리적 리두를 사용하고, 정상 작업 중에 동시성을 개선하기 위해 논리적 언두를 사용한다.

### 1.5.1 ARIES 복구 3단계

1. **분석 단계**: 페이지 캐시의 더티 페이지와 충돌 시점에 진행 중이었던 트랜잭션을 식별
2. **리두 단계**: 충돌 지점까지의 기록을 반복하고 데이터베이스를 이전 상태로 복원
3. **언두 단계**: 모든 불완전한 트랜잭션을 롤백하고 데이터베이스를 마지막 일관된 상태로 복원

### **❓Q5) 물리적 리두 vs 논리적 언두**

**물리적 리두 (Physical Redo)** - "빠른 복구"

- **개념**: 바이트 단위로 정확히 그대로 다시 적용
- **예시**: "페이지 100의 50번째 바이트를 0x41에서 0x42로 변경"
- **장점**: 매우 빠름, 단순함, 확실함

**논리적 언두 (Logical Undo)** - "유연한 되돌리기"

- **개념**: 무엇을 했는지 기록하고, 그 반대 작업을 수행
- **예시**: "INSERT users VALUES ('kim123')" → "DELETE users WHERE id='kim123'"
- **장점**: 유연함, 동시성, 논리적

**왜 이 조합을 사용할까?**

- **리두(복구)**: "빨리 원상복구하자!" → 물리적으로 바이트 단위 복사가 가장 빠름
- **언두(롤백)**: "다른 작업 방해하지 말고 되돌리자!" → 논리적으로 작업 단위 취소가 가장 안전

# 2. Concurrency Control (동시성 제어)

## 2.1 동시성 제어 기법 분류

- **낙관적 동시성 제어 (OCC)**: 트랜잭션이 동시적인 읽기 및 쓰기 작업을 실행하고, 커밋 전에 충돌을 확인
- **다중 버전 동시성 제어 (MVCC)**: 타임스탬프로 식별되는 과거 시점에서 데이터베이스의 일관된 뷰를 보장
- **비관적 동시성 제어 (PCC)**: 락 기반 및 비락킹 보수적 방법으로 공유 자원에 대한 접근을 관리

## 2.2 Serializability (직렬화 가능성)

스케줄이 같은 트랜잭션 집합에 대한 어떤 완전한 직렬 스케줄과 동등하면 직렬화 가능하다. 즉, 트랜잭션 집합을 어떤 순서로 하나씩 실행했을 때와 같은 결과를 생성한다.

### **❓Q6) 직렬화 가능성의 조건**

직렬화 가능성은 충돌(Conflict)과 **의존성 그래프**로 판단할 수 있다.

1. **모든 충돌 찾기** (같은 데이터 + 쓰기 포함)
2. **의존성 그래프 그리기** (충돌 순서대로)
3. **사이클 확인하기**
    - 사이클 없음 → **직렬화 가능** ✅
    - 사이클 있음 → **직렬화 불가능** ❌

**충돌하는 조건은 아래의 3가지 조건을 모두 만족해야 한다.**

1. **같은 데이터** 항목에 접근
2. **서로 다른 트랜잭션**
3. **적어도 하나는 쓰기** 작업

```
T1: Read(X), Write(Y)
T2: Read(Y), Write(X)

의존성:
T1 ---> T2 (T1의 W(Y)가 T2의 R(Y)보다 먼저)
T2 ---> T1 (T2의 W(X)가 T1의 R(X)보다 먼저)

결과: T1 → T2 → T1 (사이클!) → 직렬화 불가능
```

## 2.3 Transaction Isolation (트랜잭션 격리)

격리 수준은 트랜잭션의 부분들이 언제 그리고 어떻게 다른 트랜잭션에게 가시화될 수 있는지를 명시한다.

### 2.3.1 읽기 이상 현상

- **더티 읽기**: 트랜잭션이 다른 트랜잭션의 커밋되지 않은 변경 사항을 읽는 상황
- **반복 불가능한 읽기**: 트랜잭션이 같은 행을 두 번 쿼리하고 다른 결과를 얻는 상황
- **팬텀 읽기**: 트랜잭션이 같은 행 집합을 두 번 쿼리하고 다른 결과를 받는 경우

### **❓Q7) ‘팬텀 읽기’와 ‘반복 불가능한 읽기’의 차이**

**반복 불가능한 읽기**: "기존 행의 값이 바뀜" - **UPDATE 문제**

```sql
-- T1: 김철수 잔액 확인
SELECT balance FROM accounts WHERE name = '김철수';
-- 결과: 1000원

-- T2: 김철수 입금 (동시에 실행)
UPDATE accounts SET balance = 1500 WHERE name = '김철수';

-- T1: 다시 김철수 잔액 확인
SELECT balance FROM accounts WHERE name = '김철수';
-- 결과: 1500원 ← 값이 바뀜!
```

**팬텀 읽기**: "행의 개수가 바뀜" - **INSERT/DELETE 문제**

```sql
-- T1: 20대 사용자 조회
SELECT * FROM users WHERE age BETWEEN 20 AND 29;
-- 결과: 김철수(25), 박영희(28) → 2명

-- T2: 새로운 20대 사용자 추가
INSERT INTO users VALUES ('이민수', 24);

-- T1: 다시 20대 사용자 조회
SELECT * FROM users WHERE age BETWEEN 20 AND 29;
-- 결과: 김철수(25), 박영희(28), 이민수(24) → 3명 ← 개수가 바뀜!
```

**왜 제어 방법이 다를까?**

- **반복 불가능한 읽기 방지**: **행 락킹**으로 해결 (특정 행에 락)
- **팬텀 읽기 방지**: **범위 락킹** 필요 (특정 범위에 락)

### 2.3.2 Isolation Levels (격리 수준)

| 격리 수준 | Dirty Read | Non-repeatable Read | Phantom Read |
| --- | --- | --- | --- |
| **Read Uncommitted** | ❌ 발생 | ❌ 발생 | ❌ 발생 |
| **Read Committed** | ✅ 방지 | ❌ 발생 | ❌ 발생 |
| **Repeatable Read** | ✅ 방지 | ✅ 방지 | ❌ 발생 |
| **Serializable** | ✅ 방지 | ✅ 방지 | ✅ 방지 |

**Read Committed**: 읽는 행에 공유 락 → 읽기 완료 후 즉시 해제

- 더티 읽기는 방지하지만, 반복 불가능한 읽기와 팬텀 읽기는 발생

**Repeatable Read**: 읽은 행에 락 유지 → 트랜잭션 끝까지

- 반복 불가능한 읽기는 방지하지만, 팬텀 읽기는 여전히 발생

**Serializable**: 범위 락(Range Lock) 또는 완전 직렬화

- 모든 이상 현상 방지

### 2.3.3 스냅샷 격리

스냅샷 격리 하에서, 트랜잭션은 그것이 시작된 시간까지 커밋된 모든 트랜잭션에 의해 수행된 상태 변경을 관찰할 수 있다. 각 트랜잭션은 데이터의 스냅샷을 가져와서 그것에 대해 쿼리를 실행한다.
