# B-Tree 구현 (재조정, 압축, 유지보수)


## 1. Rebalancing (재조정)


### 1.1 재조정의 목적

분할과 병합 연산을 줄이기 위해, 같은 레벨 내에서 요소들을 재조정하거나 더 많이 차 있는 노드에서 덜 차 있는 노드로 요소들을 이동시킨다. 최종적으로 분할이나 병합을 수행하기 전까지 가능한 한 오래 유지할 수 있다.

### 1.2 재조정의 장점과 비용

- **장점**: 노드 점유율을 개선하고 트리 내 레벨 수를 줄일 수 있음
- **비용**: 재조정을 위한 더 높은 유지보수 비용이 발생함

### 1.3 Load Balancing 기법

**1.3.1 삽입 시 공간 최적화**

- 노드가 오버플로우될 때 분할하는 대신, 일부 요소를 형제 노드 중 하나로 전송하여 삽입을 위한 공간을 확보

**1.3.2 삭제 시 최소 점유율 유지**

- 형제 노드들을 병합하는 대신, 인접 노드들에서 일부 요소를 이동시켜 노드가 최소한 절반은 차도록 보장

### 1.4 B*-Tree의 분산 전략

B*-Tree는 양쪽 형제 노드가 모두 가득 찰 때까지 인접 노드들 간에 데이터를 분산시킨다. 그 후 단일 노드를 두 개의 절반 빈 노드로 분할하는 대신, 두 노드를 세 노드로 분할하며 각각은 2/3가 차게 한다.

- SQLite에서 이 변형을 사용함
- 분할을 줄임으로써 평균 점유율을 개선하지만, 추가적인 추적 및 균형 로직이 필요
- 트리 높이가 더 작고 검색된 리프까지의 경로에서 더 적은 페이지를 탐색할 수 있음

## 2. Right-Only Appends


### 2.1 자동 증가 키의 특성

많은 데이터베이스 시스템은 기본 인덱스 키로 자동 증가하는 단조 증가 값을 사용하여 최적화 한다.

- 모든 삽입이 인덱스의 끝(가장 우측 리프) 쪽에서 발생
- 대부분의 분할이 각 레벨의 가장 우측 노드에서 발생
- 키가 단조 증가하므로 삽입보다 업데이트와 삭제의 비율이 낮을 때, 비리프 페이지들도 무작위 순서 키의 경우보다 덜 단편화 됨

### 2.2 Fastpath (PostgreSQL)

PostgreSQL에서는 이 경우를 fastpath라고 부른다.

삽입된 키가 가장 우측 페이지의 첫 번째 키보다 엄격히 클 때,
가장 우측 페이지에 새로 삽입된 항목을 담을 충분한 공간이 있을 때,
새 항목을 캐시된 가장 우측 리프의 적절한 위치에 삽입하고 전체 읽기 경로를 건너뛸 수 있다.

### 2.3 Quickbalance (SQLite)

SQLite는 유사한 개념을 quickbalance라고 부른다.

항목이 맨 우측 끝에 삽입되고 대상 노드가 가득 찰 때 (즉, 삽입 시 트리에서 가장 큰 항목이 될 때),
재조정이나 노드 분할 대신, 새로운 가장 우측 노드를 할당하고 그 포인터를 부모에 추가한다.

## 3. Bulk Loading (벌크 로딩)


### 3.1 벌크 로딩의 개념

정렬된 데이터가 있고 이를 벌크 로드하거나 트리를 재구축해야 하는 경우 (조각 모음을 위해), 오른쪽 추가 기법을 활용할 수 있다.

### 3.2 벌크 로딩의 장점

트리 생성에 필요한 데이터가 이미 정렬되어 있으므로, 벌크 로딩 중에는 트리의 가장 우측 위치에 항목들을 추가하기만 하면 된다.

- 분할과 병합을 완전히 피하고 트리를 바닥부터 구성할 수 있음

### 3.3 구현 방식

**3.3.1 리프 레벨 우선 작성**

- 정렬된 데이터를 개별 요소 삽입이 아닌 페이지 단위로 작성
- 리프 페이지가 작성된 후, 첫 번째 키를 부모로 전파하고 상위 B-Tree 레벨 구축을 위한 일반 알고리즘을 사용

**3.3.2 메모리 효율성**

- 디스크에서 분할이나 병합을 수행할 필요가 없음
- 구축 시간 동안 트리의 최소 부분(현재 채우고 있는 리프 노드의 모든 부모들)만 메모리에 유지

### 3.4 Immutable B-Tree와의 관계

**Immutable B-Tree의 장점**:

- 가변 B-Tree와 같은 방식으로 생성할 수 있지만, 후속 수정을 위한 공간 오버헤드가 필요하지 않다
- 트리의 모든 연산이 최종적이므로 모든 페이지를 완전히 채울 수 있어 점유율을 개선하고 더 나은 성능을 얻는다


## 4. Compression (압축)

### 4.1 압축의 필요성과 트레이드오프

원시 비압축 데이터를 저장하는 것은 상당한 오버헤드를 유발할 수 있으며, 많은 데이터베이스가 공간을 절약하기 위한 압축 방법을 제공한다.

- **접근 속도 vs 압축 비율**: 더 큰 압축 비율은 데이터 크기를 개선하여 단일 접근으로 더 많은 데이터를 가져올 수 있지만, 압축 및 압축 해제를 위해 더 많은 RAM과 CPU 사이클이 필요할 수 있음

### 4.2 압축 단위별 특성

**4.2.1 파일 단위 압축의 한계**

- 전체 파일 압축이 더 나은 압축 비율을 제공할 수 있지만, 큰 데이터셋에는 적용이 제한적
- 업데이트 시 전체 파일을 재압축해야 하므로 비실용적

**4.2.2 페이지 단위 압축의 장점**

- 고정 크기 페이지를 사용하는 알고리즘과 잘 맞음
- 페이지들을 서로 독립적으로 압축 및 압축 해제할 수 있어 페이지 로딩 및 플러싱과 압축을 결합할 수 있음

### 4.3 압축과 디스크 블록의 관계

**압축 페이지의 디스크 할당 문제**:

- 압축된 페이지는 디스크 블록의 일부만 차지할 수 있음
- 전송이 보통 디스크 블록 단위로 이루어지므로 추가 바이트를 페이징해야 함
- 여러 디스크 블록에 걸친 페이지들의 경우 추가 블록을 읽어야 한함

### 4.4 데이터 전용 압축

**페이지 관리와 압축의 분리**:

- 행 단위 (전체 데이터 레코드 압축) 또는 열 단위 (열을 개별적으로 압축)로 데이터만 압축하는 접근법도 있음
- 이 경우 페이지 관리와 압축이 분리됨


## 5. Vacuum and Maintenance (배큠 및 유지보수)

### 5.1 백그라운드 유지보수의 필요성

지금까지 B-Tree에서 사용자 대상 연산에 대해 주로 이야기했지만, 저장소 무결성을 유지하고, 공간을 회수하며, 오버헤드를 줄이고, 페이지를 정렬된 상태로 유지하는 다른 프로세스들이 쿼리와 병렬로 발생한다.

**백그라운드 작업의 이점**:

- 시간을 절약하고 삽입, 업데이트, 삭제 중 정리 비용을 지불하는 것을 피할 수 있음

### 5.2 Slotted Pages의 유지보수 요구사항

슬롯된 페이지의 설계는 페이지를 양호한 상태로 유지하기 위한 유지보수를 필요로 한다:

- 내부 노드의 후속 분할 및 병합
- 리프 레벨의 삽입, 업데이트, 삭제는 충분한 논리적 공간을 가지지만 연속적인 공간은 충분하지 않은 페이지를 만들 수 있음 (단편화)

### 5.3 Live와 Garbage 데이터의 구분

**Live 데이터**: 루트 레벨에서 탐색되는 B-Tree에서 루트 노드에서 포인터를 따라 내려가며 도달할 수 있는 데이터 레코드들

**Garbage 데이터**: 어디서도 참조되지 않고 읽거나 해석할 수 없는 주소 지정 불가능한 데이터 레코드들 (내용이 무효화된 것과 같음)

**가비지 영역의 제로 채우기**:

- 성능상의 이유로 가비지 영역의 제로 채우기는 생략되기도 함
- 결국 이러한 영역들은 새로운 데이터에 의해 덮어써짐


## 6. Fragmentation Caused by Updates and Deletes

### 6.1 단편화가 발생하는 상황

페이지가 주소 지정 불가능한 데이터를 가지게 되어 압축이 필요한 상태가 되는 상황을 고려해야 한다.

**리프 레벨에서의 삭제**:

- 삭제는 헤더에서 셀 오프셋만 제거하고 셀 자체는 그대로 둔다
- 이후 셀은 더 이상 주소 지정할 수 없으며, 내용이 쿼리 결과에 나타나지 않고, 무효화하거나 인접 셀을 이동시킬 필요가 없다

### 6.2 페이지 분할 시 단편화

페이지가 분할될 때, 오프셋만 정리되고 페이지의 나머지 부분은 주소 지정할 수 없으므로, 오프셋이 잘린 셀들은 도달할 수 없어서 새로운 데이터가 도착하거나 배큠 프로세스가 시작될 때 덮어써진다.

### 6.3 업데이트와 단편화

**구조적 변경의 제한**:

- 업데이트는 대부분 리프 레벨에 적용된다 (내부 페이지 키는 안내된 탐색에 사용되며 서브트리 경계만 정의함)
- 업데이트는 키별로 수행되며, 일반적으로 오버플로우 페이지 생성을 제외하고는 트리의 구조적 변경을 초래하지 않는다

**셀 순서와 페이지 재작성**:

- 리프 레벨에서 업데이트 연산은 셀 순서를 변경하지 않고 페이지 재작성을 피하려고 한다
- 이는 하나만 주소 지정 가능한 셀의 여러 버전이 저장될 수 있음을 의미한다


## 7. Page Defragmentation

### 7.1 역단편화 프로세스

공간 회수와 페이지 재작성을 처리하는 프로세스를 압축(compaction), 배큠(vacuum), 또는 유지보수(maintenance)라고 한다.

**7.1.1 동기 vs 비동기 처리**

- 페이지에 충분한 여유 물리적 공간이 없는 경우 (불필요한 오버플로우 페이지 생성을 피하기 위해) 쓰기 시 동기적으로 페이지 재작성을 수행할 수 있다
- 압축은 대부분 페이지들을 거쳐가며 가비지 수집을 수행하고 내용을 재작성하는 별개의 비동기 프로세스로 언급된다

### 7.2 압축의 효과

**7.2.1 공간 회수와 재정렬**

- 삭제된 셀들이 차지한 공간을 회수하고, 셀들을 논리적 순서로 재작성
- 페이지들이 재작성될 때, 파일의 새로운 위치로 재배치될 수도 있음
- 사용되지 않는 메모리 내 페이지들이 사용 가능해지고 페이지 캐시로 반환됨

**7.2.2 Free Page List 관리**

- 새로 사용 가능해진 온디스크 페이지들의 ID가 **free page list** (때로는 freelist라고 불림)에 추가됨
