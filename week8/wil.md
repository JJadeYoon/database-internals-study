# Chapter 5: 트랜잭션 처리 및 버퍼 관리

## 1. Buffer Management 개요

**목적**: 느린 디스크와 빠른 메모리 사이의 속도 차이를 해결

- 디스크: 밀리초 (10⁻³초)
- 메모리: 나노초 (10⁻⁹초)
- 약 100만배 차이가 남

**해결책**: 페이지 캐시 시스템

- 자주 사용되는 페이지를 메모리에 캐시
- 2단계 메모리 계층 구축

### Q1) 스토리지엔진이란?

데이터베이스에서 실제 데이터 저장/조회를 담당하는 컴포넌트

- B-Tree, LSM Tree 등 자료구조 구현
- 페이지 캐시의 "클라이언트" 역할
- 예: MySQL InnoDB, PostgreSQL 내장 엔진, MongoDB WiredTiger

```
쿼리 → 스토리지 엔진 ("페이지 #123 주세요") → 페이지 캐시 ("메모리에 있나 확인") → 디스크 (실제 데이터 저장소)     
```

### Q2) "직접적인 매핑이 없다"?

디스크의 물리적 순서와 메모리의 배치 순서가 다르다는 의미

**디스크 (순차적)**:

```
[페이지1][페이지2][페이지3][페이지4][페이지5]
```

**메모리 캐시 (무작위)**:

```
[페이지4][빈공간][페이지1][페이지5][페이지2]
```

**이유**:

- 요청 순서대로 로딩
- 사용 가능한 슬롯에 배치
- 실제 접근은 순차적이지 않음 (B-Tree: 루트→중간→리프)

## 2. 페이지 캐시 (Page Cache)

### 2.1 기본 구조

```
스토리지 엔진 → 페이지 캐시 → 디스크
    ↑           ↑         ↑
논리적 요청    메모리 관리   물리적 저장
```

### 2.2 주요 기능

- 캐시된 페이지 내용을 메모리에 보관
- 디스크 페이지 수정을 메모리에서 버퍼링
- 페이지 로딩/축출 관리
- 더티 페이지 플러시

### 2.3 용어 정리

- **페이지 캐시** vs **버퍼 풀**: 같은 개념, 다른 표현
- **Paged in**: 디스크에서 메모리로 로드
- **Dirty**: 수정되었지만 아직 디스크에 안 씀
- **Flushed**: 디스크에 동기화됨
- **Evicted**: 메모리에서 제거됨

## 3. Caching Semantics (캐싱 의미론)

### 3.1 핵심 가정

- "다른 프로세스가 디스크 데이터를 수정하지 않았다"
- 캐시된 복사본이 원본과 일치한다고 가정

### 3.2 동기화 시점

1. **페이지 축출 시**: 더티 페이지는 반드시 플러시 후 축출
2. **백그라운드 플러시**: 주기적으로 더티 페이지 디스크 쓰기
3. **체크포인트**: 모든 더티 페이지 강제 플러시
4. **트랜잭션 커밋**: WAL 먼저, 데이터 페이지는 나중

### 3.3 버퍼 상태

- **Clean**: 디스크와 동일
- **Dirty**: 수정됨, 디스크 동기화 필요
- **Pinned**: 축출 금지
- **Referenced**: 현재 사용 중

### Q3) 페이지가 동기화 되는 시점은?

다음 5가지 시점에 동기화된다.

1. **페이지 축출 시** (강제)
    
    ```python
    if page.is_dirty():
        disk.write(page_id, page.data)  # 반드시 디스크에 쓰기
    ```
    
2. **백그라운드 플러시** (선제적)
    - PostgreSQL의 background flush writer
    - 주기적으로 더티 페이지 디스크 쓰기
3. **체크포인트** (주기적, 가장 중요)
    - WAL과 페이지 캐시 조정
    - 모든 더티 페이지 강제 플러시
4. **트랜잭션 커밋** (WAL 우선)
    - WAL 먼저 디스크에 쓰기
    - 실제 데이터 페이지는 나중에
5. **시스템 종료** (정상 종료시)

### Q4: 논리적 B-Tree?

**A**: 실제로 "어디에" 있는 것이 아니라 **개념적 구조**입니다

**3가지 계층**:

1. **논리적 B-Tree**: 소프트웨어 알고리즘/개념 (설계도)
2. **물리적 디스크**: 실제 페이지 데이터 저장 (창고)
3. **메모리 캐시**: 자주 쓰는 페이지 임시 보관 (작업대)

**동작 과정**:

```python
# 1. 논리적 계획
"키 15를 찾기 위해 루트→중간→리프 순서로 탐색"

# 2. 물리적 요청
root_page = page_cache.get_page(1)  # 페이지 캐시에 요청
node = BTreeNode.from_bytes(root_page)  # 임시 객체화

# 3. 탐색 계속...
```

### Q5)"객체를 실체화하지 않는다"?

전체 B-Tree를 객체로 메모리에 로드하지 않는다는 의미이다. 메모리 효율적, 빠른 시작, 확장 가능하다는 장점이 있다.

**객체 실체화 방식**:

```python
# 모든 노드를 완전한 객체로 로드
root = BTreeNode()
root.children = [BTreeNode(), BTreeNode(), ...]  # 거대한 객체 네트워크
```

**페이지 캐시 방식**:

```python
# 바이트 데이터만 보관, 필요시에만 해석
page_cache = {
    1: bytes([0x12, 0x34, ...]),  # raw 바이트
    2: bytes([0x56, 0x78, ...]),
}

# 필요할 때만 임시 객체화
node = BTreeNode.parse_from_bytes(page_cache[1])
```

## 4. Cache Eviction (캐시 축출)

### 4.1 트레이드오프 목표들

- 디스크 접근 횟수 줄이기
- 빠른 축출을 위한 선제적 플러시
- 최적 순서로 페이지 선택
- 메모리 경계 내 캐시 크기 유지
- 데이터 손실 방지

### 4.2 축출 조건

- 메모리 공간 부족시
- 더티 페이지는 플러시 후 축출
- 참조된 페이지는 축출 불가

## 5. 캐시에서 페이지 락킹

### 5.1 Pinning 개념

- 자주 사용되는 페이지를 메모리에 고정
- B-Tree 상위 노드들이 주요 대상
- 디스크 접근 횟수 대폭 감소

### 5.2 버퍼링 효과

- 여러 구조적 변경사항을 메모리에서 모아 처리
- 한 번의 디스크 쓰기로 여러 변경사항 반영

### Q6) 버퍼란?

1. **물리적**: 메모리의 특정 영역 (8KB 바이트 배열)
    
    음식점 조리대: 재료를 모아서 요리하는 작업 공간
    
2. **논리적**: 페이지를 담는 스마트한 컨테이너
    
    택배 집하장: 개별 택배를 모아서 한 번에 운송
    
3. **기능적**: 변경사항을 모아두는 임시 저장소
    
    은행 창구 책상: 여러 서류를 모아서 처리
    

## 6. Page Replacement 알고리즘

### 6.1 FIFO (First In, First Out)

- 가장 오래된 페이지부터 축출
- 단순하지만 비효율적
- 실제 사용 패턴 무시

### 6.2 LRU (Least Recently Used)

- 가장 최근에 사용되지 않은 페이지 축출
- 접근할 때마다 큐 재정렬 필요
- 동시성 환경에서 오버헤드

### 6.3 CLOCK Algorithm

- LRU의 효율적인 근사
- 원형 버퍼 + 접근 비트 사용
- 클록 포인터가 순환하며 비트 검사
    - 비트 1 → 0으로 변경, 다음으로
    - 비트 0 → 축출 후보

### 6.4 LFU (Least Frequently Used)

- 사용 빈도가 낮은 페이지 축출
- TinyLFU: 3개 큐 사용 (Admission, Probation, Protected)
- 빈도 히스토그램으로 효율적 관리

### Q7) CAS가 왜 락 없이도 안전한가?

하드웨어가 원자적으로 "조건부 업데이트"를 수행하기 때문이다.

**문제 상황**:

```
계좌 잔고: 1000원
ATM-A: 500원 출금
ATM-B: 300원 출금

일반 방식: 700원 (잘못됨, 500원 출금 손실)
CAS 방식: 200원 (정확함)

```

**CAS 동작**:

```
1. ATM-A: CAS(1000, 500) → 성공 ✅
2. ATM-B: CAS(1000, 700) → 실패 ❌ (이미 500원)
3. ATM-B: CAS(500, 200) → 성공 ✅

```

**하드웨어 보장**:

- CPU가 CAS를 하나의 끊을 수 없는 명령으로 실행
- 메모리 버스를 나노초 동안 독점
- 매우 짧은 "하드웨어 락" = 성능 영향 없음
